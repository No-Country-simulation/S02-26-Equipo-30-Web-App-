def deployApp(Map config) {
    def composeFile = config.composeFile ?: 'docker-compose.yml'

    // Mapping variables to the IDs passed from the stage
    def sshCredId = config.sshKeyCredentialId
    def vmHostCredId = config.vmHostCredentialId
    def dbNameCredId = config.dbUserCredentialId    // This holds 'HorseTrustDb1'
    def dbPassCredId = config.dbPasswordCredentialId
    def dbUrlCredId = config.dbUrlCredentialId
    def secretKeyCredId = config.secretKeyCredentialId
    def dockerCredId = config.dockerCredentialId

    // Validation
    def missing = []
    if (!sshCredId) missing << 'sshKeyCredentialId'
    if (!vmHostCredId) missing << 'vmHostCredentialId'
    if (!dbNameCredId) missing << 'dbUserCredentialId'
    if (!dbPassCredId) missing << 'dbPasswordCredentialId'
    if (!dbUrlCredId) missing << 'dbUrlCredentialId'
    if (!secretKeyCredId) missing << 'secretKeyCredentialId'
    if (!dockerCredId) missing << 'dockerCredentialId'
    if (missing) { error("Missing required credential ids: ${missing.join(', ')}") }

    def creds = [
        sshUserPrivateKey(credentialsId: sshCredId, keyFileVariable: 'SSH_KEY'),
        string(credentialsId: vmHostCredId, variable: 'VM_HOST'),
        string(credentialsId: dbNameCredId, variable: 'RAW_DB_NAME'),
        string(credentialsId: dbPassCredId, variable: 'POSTGRES_PASSWORD'),
        string(credentialsId: dbUrlCredId, variable: 'POSTGRES_DOCKER_URL'),
        string(credentialsId: secretKeyCredId, variable: 'SECRET_KEY'),
        usernamePassword(credentialsId: dockerCredId, usernameVariable: 'DOCKERHUB_USER', passwordVariable: 'DOCKERHUB_PASS')
    ]

    withCredentials(creds) {
         def deployImage = "edydockers/backend-horsetrust"
         def imageTag = config.imageTag
         def fullBackendImage = "${deployImage}:${imageTag}"

         // Helper to clean invisible characters (CRLF) and quotes
         def clean = { v ->
            if (v == null) return ''
            def s = v.replaceAll('\r', '').trim()
            if ((s.startsWith("'") && s.endsWith("'")) || (s.startsWith('"') && s.endsWith('"'))) {
                s = s.substring(1, s.length()-1)
            }
            return s
         }

         def cleanedDbName = clean(RAW_DB_NAME)
         def cleanedDbPass = clean(POSTGRES_PASSWORD)
         def cleanedDbUrl = clean(POSTGRES_DOCKER_URL)
         def cleanedSecretKey = clean(SECRET_KEY)

         // Build the .env file content
         // Note: We use cleanedDbName for both USER and DB to match standard Postgres Docker behavior
         def envLines = []
         envLines << "BACKEND_IMAGE=${fullBackendImage}"
         envLines << "COMPOSE_PROJECT_NAME=horsetrust-backend"
         envLines << "POSTGRES_HOST=database"
         envLines << "POSTGRES_PORT=5432"
         envLines << "POSTGRES_DB=${cleanedDbName}"
         envLines << "POSTGRES_USER=postgres"
         envLines << "POSTGRES_PASSWORD=${cleanedDbPass}"
         envLines << "SPRING_DATASOURCE_URL=${cleanedDbUrl}"
         envLines << "SPRING_PROFILES_ACTIVE=prod"
         envLines << "SECRET_KEY=${cleanedSecretKey}"

         def envContent = envLines.join('\n')

         echo "Deploying to ${VM_HOST}. DB Name used: ${cleanedDbName}"

         // 1. Prepare directory
         sh "ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no ${VM_USER}@${VM_HOST} 'mkdir -p ${VM_PROJECT_PATH}'"

         // 2. Transfer Docker Compose
         sh "scp -i ${SSH_KEY} -o StrictHostKeyChecking=no backend/horse-retail/infrastructure/docker/${composeFile} ${VM_USER}@${VM_HOST}:${VM_PROJECT_PATH}/docker-compose.yml"

         // 3. Generate and transfer .env
         writeFile file: 'remote.env', text: envContent
         sh "scp -i ${SSH_KEY} -o StrictHostKeyChecking=no remote.env ${VM_USER}@${VM_HOST}:${VM_PROJECT_PATH}/.env"

         // 4. Remote execution
         // WE ADD 'docker compose down -v' to ensure the database is recreated with the NEW name
         sh """
            ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no ${VM_USER}@${VM_HOST} '
                cd ${VM_PROJECT_PATH} &&
                sudo docker network create horse-net 2>/dev/null || true &&
                echo ${DOCKERHUB_PASS} | sudo docker login -u ${DOCKERHUB_USER} --password-stdin &&
                sudo docker compose pull &&
                sudo docker compose down -v &&
                sudo docker compose up -d --force-recreate &&
                sudo docker image prune -f &&
                sudo docker logout'
         """

         sh 'rm -f remote.env'
     }
}

pipeline {
    agent { label "worker-node-02" }

    tools {
        jdk 'jdk21'
        maven 'maven3'
    }

    environment {
        VM_USER                    = 'jenkins'
        VM_PROJECT_PATH            = '/home/jenkins/horsetrust'
        IMAGE_NAME                 = "local/horsetrust"
        DOCKERHUB_CREDENTIALS      = 'edydockers-credentials'
        APP_DIR                    = 'backend/horse-retail'
        DOCKER_DIR                 = 'backend/horse-retail/infrastructure/docker'
    }

    stages {
        stage('Checkout Source Code') {
            steps {
                cleanWs(deleteDirs: true)
                checkout scm
            }
        }

        stage('Build Application') {
            steps {
                sh "mvn -f ${APP_DIR}/pom.xml clean install -DskipTests"
            }
        }

        stage('Build and Push Image') {
            steps {
                script {
                    def imageToPush = "edydockers/backend-horsetrust"
                    def imageTag = "prod-${env.BUILD_NUMBER}"

                    sh "docker build -t ${IMAGE_NAME} -f ${DOCKER_DIR}/Dockerfile ${APP_DIR}"

                    withCredentials([usernamePassword(credentialsId: env.DOCKERHUB_CREDENTIALS, usernameVariable: 'DUSER', passwordVariable: 'DPASS')]) {
                        sh "echo '${DPASS}' | docker login -u '${DUSER}' --password-stdin"
                        sh "docker tag ${IMAGE_NAME} ${imageToPush}:${imageTag}"
                        sh "docker tag ${IMAGE_NAME} ${imageToPush}:latest"
                        sh "docker push ${imageToPush}:${imageTag}"
                        sh "docker push ${imageToPush}:latest"
                        sh "docker logout"
                    }
                }
            }
        }

        stage('Deploy to Production') {
            steps {
                script {
                    deployApp(
                        vmHostCredentialId: 'vm-ip-98',
                        imageTag: "prod-${env.BUILD_NUMBER}",
                        sshKeyCredentialId: 'vm-ssh-key-98',
                        dbUserCredentialId: 'horsetrust-db-name',   // Injects 'HorseTrustDb1'
                        dbPasswordCredentialId: 'horsetrust-db-pass',
                        dbUrlCredentialId: 'horsetrust-db-url',     // Ensure this ends in /HorseTrustDb1
                        secretKeyCredentialId: 'horsetrust-secret-key'
                    )
                 }
             }
         }
    }

    post {
        always {
            sh "docker rmi ${IMAGE_NAME} || true"
            cleanWs()
        }
    }
}