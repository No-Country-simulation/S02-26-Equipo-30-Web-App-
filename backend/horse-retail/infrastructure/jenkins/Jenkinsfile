def deployApp(Map config) {
    def composeFile = config.composeFile ?: 'docker-compose.yml'

    // 1. Map Variables from Parameters
    def sshCredId = config.sshKeyCredentialId
    def vmHostCredId = config.vmHostCredentialId
    def dbNameCredId = config.dbUserCredentialId    // Holds 'HorseTrustDb1'
    def dbPassCredId = config.dbPasswordCredentialId
    def dbUrlCredId = config.dbUrlCredentialId
    def secretKeyCredId = config.secretKeyCredentialId
    def dockerCredId = config.dockerCredentialId

    // 2. Validation
    def missing = []
    if (!sshCredId) missing << 'sshKeyCredentialId'
    if (!vmHostCredId) missing << 'vmHostCredentialId'
    if (!dbNameCredId) missing << 'dbUserCredentialId'
    if (!dbPassCredId) missing << 'dbPasswordCredentialId'
    if (!dbUrlCredId) missing << 'dbUrlCredentialId'
    if (!secretKeyCredId) missing << 'secretKeyCredentialId'
    if (!dockerCredId) missing << 'dockerCredentialId'
    if (missing) { error("Missing required credential ids: ${missing.join(', ')}") }

    def creds = [
        sshUserPrivateKey(credentialsId: sshCredId, keyFileVariable: 'SSH_KEY'),
        string(credentialsId: vmHostCredId, variable: 'VM_HOST'),
        string(credentialsId: dbNameCredId, variable: 'RAW_DB_NAME'),
        string(credentialsId: dbPassCredId, variable: 'POSTGRES_PASSWORD'),
        string(credentialsId: dbUrlCredId, variable: 'POSTGRES_DOCKER_URL'),
        string(credentialsId: secretKeyCredId, variable: 'SECRET_KEY'),
        usernamePassword(credentialsId: dockerCredId, usernameVariable: 'DUSER', passwordVariable: 'DPASS')
    ]

    withCredentials(creds) {
         def imageTag = config.imageTag
         def fullBackendImage = "edydockers/backend-horsetrust:${imageTag}"

         // Helper to clean quotes or hidden characters
         def clean = { v ->
            if (v == null) return ''
            def s = v.replaceAll('\r', '').trim()
            if ((s.startsWith("'") && s.endsWith("'")) || (s.startsWith('"') && s.endsWith('"'))) {
                s = s.substring(1, s.length()-1)
            }
            return s
         }

         def cleanedDbName = clean(RAW_DB_NAME)

         // 3. Build .env file with Swagger & Proxy Fixes
         def envLines = []
         envLines << "BACKEND_IMAGE=${fullBackendImage}"
         envLines << "POSTGRES_DB=${cleanedDbName}"
         envLines << "POSTGRES_PASSWORD=${clean(POSTGRES_PASSWORD)}"
         envLines << "SPRING_DATASOURCE_URL=${clean(POSTGRES_DOCKER_URL)}"
         envLines << "SECRET_KEY=${clean(SECRET_KEY)}"

         // Swagger UI Production Visibility
         envLines << "SPRINGDOC_SWAGGER_UI_ENABLED=true"
         envLines << "SPRINGDOC_API_DOCS_ENABLED=true"

         // Nginx Reverse Proxy Headers Strategy
         envLines << "SERVER_FORWARD_HEADERS_STRATEGY=framework"

         // Swagger JSON Path Fixes
         envLines << "SPRINGDOC_CONFIG_PATH=/v3/api-docs"
         envLines << "SPRINGDOC_SWAGGER-UI_CONFIG-URL=/v3/api-docs/swagger-config"
         envLines << "SPRINGDOC_SWAGGER-UI_URL=/v3/api-docs"

         // 4. File Transfers
         writeFile file: 'remote.env', text: envLines.join('\n')
         sh "ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no ${VM_USER}@${VM_HOST} 'mkdir -p ${VM_PROJECT_PATH}'"
         sh "scp -i ${SSH_KEY} -o StrictHostKeyChecking=no backend/horse-retail/infrastructure/docker/${composeFile} ${VM_USER}@${VM_HOST}:${VM_PROJECT_PATH}/docker-compose.yml"
         sh "scp -i ${SSH_KEY} -o StrictHostKeyChecking=no remote.env ${VM_USER}@${VM_HOST}:${VM_PROJECT_PATH}/.env"

         // 5. Remote Execution: Kill, Start DB, Force Create DB, Start App
         sh """
            ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no ${VM_USER}@${VM_HOST} '
                cd ${VM_PROJECT_PATH} &&
                sudo docker network create horse-net 2>/dev/null || true &&

                # Forced cleanup of ghost containers
                sudo docker rm -f horsetrust-backend-database-1 horsetrust-backend-spring-1 2>/dev/null || true

                # Pull and start database only
                echo ${DPASS} | sudo docker login -u ${DUSER} --password-stdin &&
                sudo docker compose up -d database

                # Wait for DB birth and manually create the database room
                echo "Waiting for database to initialize..."
                sleep 12
                sudo docker exec horsetrust-backend-database-1 psql -U postgres -c "CREATE DATABASE \\"${cleanedDbName}\\";" || true

                # Start the Spring Application
                sudo docker compose up -d spring

                # Final restart to ensure connection link is fresh
                sleep 5
                sudo docker restart horsetrust-backend-spring-1

                sudo docker logout'
         """
         sh 'rm -f remote.env'
     }
}

pipeline {
    agent { label "worker-node-02" }

    tools {
        jdk 'jdk21'
        maven 'maven3'
    }

    environment {
        VM_USER                    = 'jenkins'
        VM_PROJECT_PATH            = '/home/jenkins/horsetrust'
        IMAGE_NAME                 = "local/horsetrust"
        DOCKERHUB_CREDENTIALS      = 'edydockers-credentials'
        APP_DIR                    = 'backend/horse-retail'
        DOCKER_DIR                 = 'backend/horse-retail/infrastructure/docker'
    }

    stages {
        stage('Checkout Source Code') {
            steps {
                cleanWs(deleteDirs: true)
                checkout scm
            }
        }

        stage('Build Application') {
            steps {
                sh "mvn -f ${APP_DIR}/pom.xml clean install -DskipTests"
            }
        }

        stage('Build and Push Image') {
            steps {
                script {
                    def imageToPush = "edydockers/backend-horsetrust"
                    def imageTag = "prod-${env.BUILD_NUMBER}"

                    sh "docker build -t ${IMAGE_NAME} -f ${DOCKER_DIR}/Dockerfile ${APP_DIR}"

                    withCredentials([usernamePassword(credentialsId: env.DOCKERHUB_CREDENTIALS, usernameVariable: 'DUSER', passwordVariable: 'DPASS')]) {
                        sh "echo '${DPASS}' | docker login -u '${DUSER}' --password-stdin"
                        sh "docker tag ${IMAGE_NAME} ${imageToPush}:${imageTag}"
                        sh "docker tag ${IMAGE_NAME} ${imageToPush}:latest"
                        sh "docker push ${imageToPush}:${imageTag}"
                        sh "docker push ${imageToPush}:latest"
                        sh "docker logout"
                    }
                }
            }
        }

        stage('Deploy to Production') {
            steps {
                script {
                    deployApp(
                        vmHostCredentialId: 'vm-ip-98',
                        imageTag: "prod-${env.BUILD_NUMBER}",
                        sshKeyCredentialId: 'vm-ssh-key-98',
                        dbUserCredentialId: 'horsetrust-db-name',
                        dbPasswordCredentialId: 'horsetrust-db-pass',
                        dbUrlCredentialId: 'horsetrust-db-url',
                        secretKeyCredentialId: 'horsetrust-secret-key',
                        dockerCredentialId: env.DOCKERHUB_CREDENTIALS
                    )
                 }
             }
         }
    }

    post {
        always {
            sh "docker rmi ${IMAGE_NAME} || true"
            cleanWs()
        }
    }
}